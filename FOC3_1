#include <SimpleFOC.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>

// ====== Simple Kalman Filter for IMU ======
struct SimpleKalman {
  float Q_angle;    // Process noise variance for angle
  float Q_bias;     // Process noise variance for bias
  float R_measure;  // Measurement noise variance
  
  float angle;      // The angle calculated by the Kalman filter
  float bias;       // The gyro bias calculated by the Kalman filter
  float rate;       // Unbiased rate calculated from the rate and the calculated bias
  
  float P[2][2];    // Error covariance matrix
  
  SimpleKalman() {
    // Tuned for fast response with noise rejection
    Q_angle = 0.001f;   // Process noise - smaller = trust model more
    Q_bias = 0.003f;    // Bias process noise
    R_measure = 0.03f;  // Measurement noise - smaller = trust measurements more
    
    angle = 0.0f;
    bias = 0.0f;
    
    // Initialize covariance matrix
    P[0][0] = 0.0f;
    P[0][1] = 0.0f;
    P[1][0] = 0.0f;
    P[1][1] = 0.0f;
  }
  
  float getAngle(float newAngle, float newRate, float dt) {
    // Prediction step
    rate = newRate - bias;
    angle += dt * rate;
    
    // Update error covariance matrix
    P[0][0] += dt * (dt * P[1][1] - P[0][1] - P[1][0] + Q_angle);
    P[0][1] -= dt * P[1][1];
    P[1][0] -= dt * P[1][1];
    P[1][1] += Q_bias * dt;
    
    // Innovation
    float y = newAngle - angle;
    
    // Innovation covariance
    float S = P[0][0] + R_measure;
    
    // Kalman gain
    float K[2];
    K[0] = P[0][0] / S;
    K[1] = P[1][0] / S;
    
    // Update angle and bias
    angle += K[0] * y;
    bias += K[1] * y;
    
    // Update error covariance matrix
    float P00_temp = P[0][0];
    float P01_temp = P[0][1];
    
    P[0][0] -= K[0] * P00_temp;
    P[0][1] -= K[0] * P01_temp;
    P[1][0] -= K[1] * P00_temp;
    P[1][1] -= K[1] * P01_temp;
    
    return angle;
  }
};

SimpleKalman kalmanFilter;

// ====== IMU ======
Adafruit_MPU6050 mpu;

// ====== Driver 1 Pin definitions ======
#define INH_A1 16
#define INH_B1 17
#define INH_C1 12
#define EN_GATE1 27
#define M_PWM1 26
#define M_OC1 36
#define OC_ADJ1 25

// ====== Driver 2 Pin definitions ======
#define INH_A2 32
#define INH_B2 33
#define INH_C2 19
#define EN_GATE2 13
#define M_PWM2 18
#define M_OC2 34
#define OC_ADJ2 23

#define PCA9548A_ADDR 0x70

// ====== PID Controller for Balancing ======
// Reduced D term since Kalman filter handles noise
PIDController pid_balance = PIDController(0.6, 0.33 , 0.01, 10000, 20);
const float TARGET_PITCH = -3.0;
const float DEAD_ZONE = 0.05;

// ====== Motor, Driver, Sensor ======
BLDCMotor motor1 = BLDCMotor(7, 0.1, 400);
BLDCDriver3PWM driver1 = BLDCDriver3PWM(INH_A1, INH_B1, INH_C1, EN_GATE1);

BLDCMotor motor2 = BLDCMotor(7, 0.1, 400);
BLDCDriver3PWM driver2 = BLDCDriver3PWM(INH_A2, INH_B2, INH_C2, EN_GATE2);

// ====== Encoders ======
MagneticSensorI2C encoder1 = MagneticSensorI2C(0x36, 12, 0x0E, 4);
MagneticSensorI2C encoder2 = MagneticSensorI2C(0x36, 12, 0x0E, 4);

// ====== Commander ======
Commander command = Commander(Serial);
void doMotor(char* cmd) {
  command.motor(&motor1, cmd);
  command.motor(&motor2, cmd);
}

void selectI2CChannel(uint8_t channel) {
  Wire.beginTransmission(PCA9548A_ADDR);
  Wire.write(1 << channel);
  if (Wire.endTransmission() != 0) {
    Serial.println("Failed to select I2C channel!");
    // Handle error (e.g., retry or halt)
  }
}

void setup() {
  pinMode(OC_ADJ1, OUTPUT);  // For Motor 1
  digitalWrite(OC_ADJ1, HIGH);  // Set to DVDD for max threshold (~0.2V V_DS)

  pinMode(OC_ADJ2, OUTPUT);  // For Motor 2
  digitalWrite(OC_ADJ2, HIGH);

  Serial.begin(115200);
  Serial.println("Starting initialization...");

  Wire.begin();
  Wire.setClock(400000); // Increased I2C speed to 400kHz for better performance

  // Test I2C Mux
  Wire.beginTransmission(PCA9548A_ADDR);
  if (Wire.endTransmission() != 0) {
    Serial.println("I2C Mux not found!");
    while (1) delay(1000);
  }
  Serial.println("I2C Mux found!");

  // Initialize MPU6050
  if (!mpu.begin()) {
    Serial.println("Failed to find MPU6050 chip");
    while (1) delay(10);
  }

  // Configure MPU6050 for faster response
  mpu.setAccelerometerRange(MPU6050_RANGE_4_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_94_HZ);

  // DRV8302 setup
  pinMode(M_OC1, OUTPUT); digitalWrite(M_OC1, LOW);
  pinMode(M_PWM1, OUTPUT); digitalWrite(M_PWM1, HIGH);
  pinMode(M_OC2, OUTPUT); digitalWrite(M_OC2, LOW);
  pinMode(M_PWM2, OUTPUT); digitalWrite(M_PWM2, HIGH);
  delay(200);

  // ========== Init Motor 1 ==========
  Serial.println("Initializing Motor 1...");
  selectI2CChannel(2);

  encoder1.init();
  motor1.linkSensor(&encoder1);

  driver1.voltage_power_supply = 24;
  driver1.init();
  motor1.linkDriver(&driver1);
  motor1.voltage_sensor_align = 1;
  motor1.torque_controller = TorqueControlType::voltage;
  motor1.controller = MotionControlType::torque;
  motor1.voltage_limit = 18;

  motor1.init();
  motor1.initFOC();
  motor1.target = 0;

  // ========== Init Motor 2 ==========
  Serial.println("Initializing Motor 2...");
  selectI2CChannel(3);

  encoder2.init();
  motor2.linkSensor(&encoder2);

  driver2.voltage_power_supply = 24;
  driver2.init();
  motor2.linkDriver(&driver2);
  motor2.voltage_sensor_align = 1;
  motor2.torque_controller = TorqueControlType::voltage;
  motor2.controller = MotionControlType::torque;
  motor2.voltage_limit = 18;

  motor2.init();
  motor2.initFOC();
  motor2.target = 0;

  command.add('M', doMotor, "Motor");
  Serial.println("Motors ready!");

  // Initialize Kalman filter with first measurement
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);
  float initialPitch = atan2(-a.acceleration.x, sqrt(a.acceleration.y * a.acceleration.y + a.acceleration.z * a.acceleration.z)) * 180.0 / PI;
  kalmanFilter.angle = initialPitch;
}

float getPitchKalman() {
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  // Calculate accelerometer-based pitch
  float accelPitch = atan2(-a.acceleration.x, sqrt(a.acceleration.y * a.acceleration.y + a.acceleration.z * a.acceleration.z)) * 180.0 / PI;
  
  // Get gyro rate (y-axis for pitch)
  float gyroRate = g.gyro.y * 180.0 / PI; // Convert to degrees/sec
  
  // Calculate time step
  static unsigned long lastTime = micros();
  unsigned long now = micros();
  float dt = (now - lastTime) / 1000000.0f; // Convert to seconds
  lastTime = now;
  
  // Apply Kalman filter
  float filteredPitch = kalmanFilter.getAngle(accelPitch, gyroRate, dt);
  
  return filteredPitch;
}

void loop() {
  // Get filtered pitch using Kalman filter
  float pitch = getPitchKalman();
  float pitch_error = TARGET_PITCH - pitch;

  // Apply dead zone
  if (abs(pitch_error) < DEAD_ZONE) {
    pitch_error = 0;
  }

  // Compute control voltage
  float voltage = pid_balance(pitch_error);

  // Apply voltage to motors
  motor1.target = -voltage;
  motor2.target = voltage;

  // Motor control
  selectI2CChannel(2);
  motor1.loopFOC();
  motor1.move();

  selectI2CChannel(3);
  motor2.loopFOC();
  motor2.move();

  // Reduced frequency command checking
  static unsigned long lastCommand = 0;
  if (millis() - lastCommand > 100) {
    command.run();
    lastCommand = millis();
  }

  // Less frequent debug output
  static unsigned long lastPrint = 0;
  if (millis() - lastPrint > 500) {
    Serial.print("Pitch: ");
    Serial.print(pitch, 1);
    Serial.print("Â°, Voltage: ");
    Serial.print(voltage, 2);
    Serial.println("V");
    lastPrint = millis();
  }

  // No artificial delay - run as fast as possible for maximum responsiveness
}
